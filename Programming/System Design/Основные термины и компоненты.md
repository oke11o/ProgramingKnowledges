---
создал заметку: 2024-07-31
tags:
  - system-design
  - terminology
---
### Описание

#### Архитектуры информационных систем

**Файл-сервер (устарела):**

Файл-сервер только извлекает данные из файла или базы данных и передает их клиенту для дальнейшей обработки

- небезопасно (отдавать клиенту все данные, что бы он с ними что-то делал)
- придется нагружать клиента логикой (не все клиенты имеют мощные ЭВМ)

Используется, когда мы просто загружаем какие-то файлы (Google Drive, DropBox)

![](https://i.imgur.com/O68mDRc.png)

**Клиент-сервер (популярно):**

Клиент-сервер извлекает данные из файла или база данных, обрабатывает и затем передает результат клиенту

- не отдаем лишнюю информацию
- не грузим клиента логикой
- безопасно (клиент не сможет повредить наши данные или что-то сломать)

![](https://i.imgur.com/i9SPH4n.png)

**Peer to Peer (P2P):**

Все узлы выполняют одинаковые функции - нет централизованного сервера

Нет клиента и сервера - просто одноранговые узлы (каждый узел в своем понимании является и клиентом и сервером)

Где используется:
- blockchain
- torrent

![](https://i.imgur.com/fYdTj5B.png)
#### Основные критерии ИС
##### Надежность

Надежность системы — это её способность продолжать корректно функционировать даже в неблагоприятных обстоятельствах, таких как сбои оборудования, ошибки программного обеспечения или внешние атаки.

**Метрики надежности и доступности:**

Одной из ключевых метрик, характеризующих надежность системы, является метрика доступности (availability), которая измеряется в количестве "*девяток*". Чем больше девяток, тем меньше времени система недоступна в течение года.

| Уровень доступности       | Процент  | Среднегодовое время простоя |
| ------------------------- | -------- | --------------------------- |
| Conventional Server       | 99%      | 87 часов, 40 минут          |
| Public Cloud Service      | 99.5%    | 43 часов, 50 минут          |
|                           | 99.9%    | 8 часов, 46 минут           |
| High-Availability Cluster | 99.95%   | 4 часа, 23 минуты           |
| Virtual Fault Tolerance   | 99.995%  | 26 минут, 18 секунд         |
| Continuous Availability   | 99.999%  | 5 минут, 16 секунд          |
| The Stratus Zone          | 99.9999% | 31.6 секунд                 |
**SLA (Service Level Agreement)**  — это соглашение между поставщиком услуг и его клиентами, в котором четко указаны условия предоставления услуг, включая уровень доступности, производительности и обязательства по компенсациям в случае несоответствия уровням обслуживания.

**SLA включает:**

- Обещанный уровень обслуживания (например, доступность 99.99%)
- Последствия нарушения SLO, такие как возврат денег, предоставление скидок или других компенсаций

**SLO (Service Level Objectives)** — это конкретные цели, которые команда или организация должна достичь для выполнения соглашения SLA. SLO обычно устанавливаются на основании метрик производительности и доступности системы.

**Пример SLO:**

- Достичь доступности 99.99%, что эквивалентно не более 52 минутам простоя в год

**SLI (Service Level Indicators)** — это метрики, которые измеряют фактическое выполнение сервисом установленных SLO. SLI используются для мониторинга и оценки производительности и доступности системы.

**Примеры SLI:**

- Время работы системы (Uptime)
- Время простоя системы (Downtime)
#### Масштабируемость

**Масштабируемость** — это способность системы справляться с увеличением нагрузки путем добавления ресурсов. Важно предусмотреть эффективные способы решения проблем, возникающих при росте системы.
##### Вертикальное масштабирование

**Описание:** Вертикальное масштабирование (scaling up) предполагает увеличение мощности существующих ресурсов, таких как процессоры, оперативная память и хранилища.

**Преимущества:**

- Простота: не требует изменения логики приложения.
- Единое управление: меньше сложностей с синхронизацией данных.

**Недостатки:**

- Высокая стоимость: стоимость увеличения ресурсов растет нелинейно.
- Ограниченные возможности: существует физический предел увеличения мощности.
- Возможен downtime: не все системы поддерживают горячую замену компонентов (например, замена оперативной памяти или процессора требует остановки системы).

**Пример:** Покупка более мощного сервера или улучшение конфигурации существующего.

![Вертикальное масштабирование](https://i.imgur.com/05VizGm.png)
##### Горизонтальное масштабирование

**Описание:** Горизонтальное масштабирование (scaling out) предполагает добавление дополнительных серверов или узлов в систему.

**Преимущества:**

- Масштабируемость: можно добавлять ресурсы практически бесконечно.
- Высокая доступность: отказ одного узла не приводит к отказу всей системы.
- Без downtime: новые узлы можно добавлять без остановки системы.

**Недостатки:**

- Сложность управления: необходимо обеспечить синхронизацию и согласованность данных между узлами.
- Балансировка нагрузки: требуется распределение нагрузки между серверами.

**Пример:** Добавление нескольких серверов для выполнения одной и той же задачи.

![Горизонтальное масштабирование](https://i.imgur.com/4Cqajfv.png)
##### Stateless и Stateful сервисы

**Stateless сервисы:**

- Не хранят никакого состояния между запросами.
- Масштабируются просто: каждый новый узел может обслуживать любой запрос без необходимости синхронизации с другими узлами.
- Примеры: веб-серверы, кэш-серверы.

**Stateful сервисы:**

- Хранят состояние между запросами.
- Масштабировать сложно: требуется синхронизация состояния между узлами.
- Примеры: базы данных, системы хранения сессий.
#### Производительность

##### Основополагающие метрики

**Latency (задержка)** Latency — это время, которое проходит от момента отправки клиентом запроса до начала его обработки сервером. Это важная метрика, так как она влияет на общую скорость реакции системы на запросы пользователей.

![Latency](https://i.imgur.com/TjmeqQo.png)

**Response Time (время ответа)** Response Time включает в себя время задержки (latency) и время обработки запроса сервером. Это общее время, которое проходит от момента отправки запроса до получения клиентом ответа.

![Response Time](https://i.imgur.com/8A06AST.png)
##### Low-latency приложения

Low-latency приложения требуют минимальной задержки в обработке запросов. Такие приложения должны быть оптимизированы с самого начала разработки, так как последующая оптимизация может оказаться недостаточной.

**Примеры:**

- Торговые системы для высокочастотного трейдинга
- Видеоконференции
- Онлайн-игры
##### Метрика throughput

Throughput — это пропускная способность системы, измеряемая количеством запросов, которые система может обработать за единицу времени.

**Пример:**

- Клиент отправляет 200 запросов в секунду
- Сервер обрабатывает 120 запросов и переадресует их в БД
- БД успевает обработать 100 запросов
- Сервер отправляет 95 ответов клиенту

Таким образом, из 200 запросов клиент получает 95 ответов в секунду.

![Throughput](https://i.imgur.com/Gs1g2bx.png) ![Throughput Process](https://i.imgur.com/Av2WJz7.png)
##### High-throughput приложения

High-throughput приложения ориентированы на максимальную пропускную способность, часто пренебрегая минимизацией задержек (latency).

**Примеры:**

- Системы обработки больших объемов данных
- Веб-сервисы с высокой нагрузкой
#### Удобство сопровождения

Для обеспечения эффективной работы системы необходимо учитывать следующие аспекты:

- **Observability (мониторинг)**: возможность отслеживания состояния системы в реальном времени.
- **Улучшение процессов**: автоматизация доставки кода, тестирования и деплоя.
- **Дополнительный инструментарий**: использование инструментов, уменьшающих ручное вмешательство и упрощающих управление системой.
#### Безопасность

Безопасность системы включает в себя следующие варианты:

- **Передача данных в открытом виде**: данные передаются без шифрования (небезопасный вариант).
- **Транспортное шифрование**: данные шифруются во время передачи (например, HTTPS).
- **Сквозное шифрование**: данные шифруются на стороне отправителя и расшифровываются только на стороне получателя, исключая доступ к ним на промежуточных этапах.
#### Основные свойства ИС

##### Data-intensive

Data-intensive (I/O Bound) приложения требуют обработки больших объемов данных. Основные характеристики таких приложений:

- Сохранение больших данных: необходимо эффективно сохранять и управлять большими объемами данных.
- Запоминание результатов ресурсоемких операций: кэширование или хранение результатов, чтобы избежать повторной обработки.
- Предоставление возможности поиска и фильтрации данных: оптимизация запросов для быстрого доступа к нужной информации.

**Примеры:**

- Аналитические системы
- Хранилища данных
- Поисковые системы
##### Compute-intensive

Compute-intensive (CPU Bound) приложения требуют значительных вычислительных ресурсов. Основные характеристики таких приложений:

- Выполнение множества вычислительных операций: обработка сложных алгоритмов, расчетов и моделей.
- Обработка больших объемов данных: анализ данных, машинное обучение и другие ресурсоемкие задачи.

**Примеры:**

- Научные вычисления
- Машинное обучение
- Видеокодирование
##### Read/Write Ratio

При проектировании системы важно учитывать соотношение операций чтения и записи. Это соотношение влияет на выбор технологий и оптимизацию производительности.

**Социальные сети:**

- Редко пишут посты, часто читают.
- Высокое соотношение операций чтения к записям.

**Системы логов:**

- Редко читают, чаще пишут.
- Высокое соотношение операций записи к чтению.
#### Балансировка нагрузки

Балансировка нагрузки — это процесс распределения входящего сетевого трафика на несколько серверов для обеспечения надежности, производительности и доступности сервиса.
##### Клиентская балансировка

В клиентской балансировке нагрузка распределяется самим клиентом, который имеет информацию о каждом инстансе сервера. Это решение может работать быстрее, но имеет проблемы с эксплуатацией, так как при падении одного из инстансов необходимо донести эту информацию до клиента.

**Преимущества:**

- Быстрое распределение нагрузки
- Снижение нагрузки на центральный балансировщик

**Недостатки:**

- Сложность управления клиентскими конфигурациями
- Уязвимость к падению инстансов (нужно оповещать клиентов)

![Клиентская балансировка](https://i.imgur.com/bQXkbsV.png)
##### Серверная балансировка

Серверная балансировка выполняется центральным балансировщиком нагрузки (LB), который распределяет входящий трафик между серверами.

**Преимущества:**

- Централизованное управление трафиком
- Возможность использования различных алгоритмов распределения нагрузки

**Недостатки:**

- Добавление дополнительного узла в инфраструктуру, который может стать точкой отказа

![Серверная балансировка](https://i.imgur.com/qlyj5M0.png)
##### Алгоритмы распределения нагрузки

**Random:** Выбирает инстанс случайным образом. Это может привести к неэффективному распределению нагрузки.

![Random](https://i.imgur.com/Reb6CWS.png)

**Round Robin:** Распределяет запросы по кругу. Закрывает 80-90% задач.

![Round Robin](https://i.imgur.com/ksnP0bG.png)

**Weighted Round Robin:** Взвешенный Round Robin направляет запросы на инстансы, которые могут обрабатывать больше трафика, имея больше ресурсов.

![Weighted RR](https://i.imgur.com/kr0b7O7.png)

**Sticky Sessions:** Использует хеш-таблицу для привязки пользователя к определенному инстансу.

![Sticky Sessions](https://i.imgur.com/hU0hy2K.png)

**Least Connections / RT (response time) / Bandwidth:** Балансировщик направляет трафик на сервер с наименьшим количеством активных соединений или минимальным временем отклика.

![Least Connections](https://i.imgur.com/3or89b7.png)

**Power of Two Choices:** Случайным образом выбирает два сервера и из них выбирает лучший по целевой метрике (например, наименьшее количество соединений).
#### Методы серверной балансировки
##### L4 / L7 балансировка

![](https://i.imgur.com/byABhSo.png)

**L4:** Балансировка на [сетевом и транспортном уровнях](../Сети/Модель%20ISO%20OSI.md). Работает с IP-адресами и портами, не анализируя содержимое запросов. Используется для балансировки TCP и UDP трафика.

**Особенности:**

- Простая и быстрая, так как работает на низком уровне.
- Не позволяет учитывать содержимое запросов при распределении нагрузки.

**Примеры:**

- ipvs (Linux Virtual Server)
- HAProxy в режиме TCP

**L7 (уровень 7):** Балансировка на [прикладном уровне](../Сети/Модель%20ISO%20OSI.md). Анализирует HTTP-запросы и другие протоколы прикладного уровня для принятия решений о распределении нагрузки.

**Особенности:**

- Может принимать решения на основе содержимого запросов (например, URL, заголовков, кук).
- Подходит для сложных сценариев маршрутизации и балансировки.

**Примеры:**

- Nginx
- HAProxy в режиме HTTP
- Traefik
##### DNS балансировка

![](https://i.imgur.com/Nv6EuDp.png)

DNS балансировка распределяет трафик на уровне [DNS](../Сети/Протоколы/application-layer/DNS.md), предоставляя разные IP-адреса для одного доменного имени. Когда пользователь запрашивает доменное имя, DNS-сервер возвращает один из множества IP-адресов, распределяя таким образом нагрузку между несколькими серверами.

**Особенности:**

- Простота настройки.
- Меньшая гибкость по сравнению с L4 и L7 балансировкой.
- Зависимость от времени жизни (TTL) DNS-записей, что может задерживать изменение маршрутизации.

**Примеры:**

- Amazon Route 53
- Cloudflare DNS
- Google Cloud DNS
##### geoDNS балансировка

![](https://i.imgur.com/EBrKy4j.png)

geoDNS балансировка распределяет трафик на основе географического положения пользователя, направляя его в ближайший дата-центр. Это снижает задержки и улучшает производительность за счет уменьшения времени передачи данных.

**Особенности:**

- Повышение производительности за счет уменьшения задержек.
- Улучшение пользовательского опыта за счет маршрутизации запросов в ближайший дата-центр.
- Возможность распределения нагрузки между регионами.

**Примеры:**

- Akamai
- NS1
- Amazon Route 53 с включенной геолокацией
#### Проксирование

*Проксирование* — это процесс передачи запросов и ответов между клиентом и сервером через промежуточный сервер, называемый прокси-сервером.

**Основные функции проксирования:**

- **Взлом / защита:**
    - Защита внутренних сетей от внешних атак.
    - Фильтрация нежелательного контента и блокировка вредоносных запросов.
    
- **Кэширование данных:**
    - Хранение копий часто запрашиваемых ресурсов для ускорения доступа к ним.
    - Снижение нагрузки на исходный сервер за счет уменьшения числа запросов.
    
- **Ограничения трафика:**
    - Контроль и управление трафиком для предотвращения перегрузок.
    - Ограничение скорости передачи данных и количества соединений.
    
- **Обход ограничений доступа:**
    - Доступ к заблокированным ресурсам через прокси-серверы.
    - Изменение IP-адреса для обхода географических или сетевых ограничений.
    
-  **Анонимность пользователей:**
    - Сокрытие реального IP-адреса пользователя.
    - Повышение конфиденциальности и безопасности в Интернете.
    
-  **Сжатие и модификация данных:**
    - Сжатие передаваемых данных для уменьшения объема трафика.
    - Изменение содержимого запросов и ответов в соответствии с правилами прокси-сервера.

![Основные функции проксирования](https://i.imgur.com/ZCIMzEg.png)
##### Виды проксирования

**Forward Proxy (прямой прокси):** Клиент (приложение) знает, что он идет через прокси-сервер. Прямой прокси используется для выполнения запросов от клиента к серверу от имени клиента.

**Применение:**

- Доступ к внешним ресурсам из закрытой сети.
- Кэширование и фильтрация трафика.

**Пример:** Использование прокси для доступа к интернет-ресурсам из корпоративной сети.

![Forward Proxy](https://i.imgur.com/dOpAnJm.png)

**Reverse Proxy (обратный прокси):** Клиент (приложение) не знает, что его запросы обрабатываются через прокси-сервер. Обратный прокси используется для передачи запросов от клиента к серверу и обратно, скрывая реальный сервер.

**Применение:**

- Балансировка нагрузки между несколькими серверами.
- Кэширование и защита внутренних серверов.
- SSL-терминация (расшифровка HTTPS-запросов).

**Пример:** Nginx или HAProxy, выступающие в роли обратного прокси для веб-сервиса.

![](https://i.imgur.com/d07hFJQ.png)
#### Кэширование
Кэширование — это процесс хранения данных в временном хранилище (кэше) для быстрого доступа к ним в будущем. Это помогает сократить время ответа сервисов, снизить нагрузку на сторонние сервисы и повторно использовать ранее полученные или вычисленные данные. Также кэширование может стабилизировать работу при кратковременных отказах систем.

#### Основные термины

- **Cache miss** — промах кэша, когда запрошенный ключ не был найден в кэше.
- **Cache hit** — попадание в кэш, когда запрошенный ключ найден в кэше.
- **Hit ratio** — процент попаданий запросов в кэш, характеризует эффективность кэширования.
- **Горячий ключ** — ключ, на который приходится большая часть запросов.
- **Прогрев кэша** — процесс наполнения кэша данными.
- **Инвалидация** — удаление кэшированных данных.

#### Какие данные кэшировать

- **Меняются часто (секунды)** — кэшировать часто бессмысленно, но иногда может пригодиться.
- **Меняются нечасто (минуты и часы)** — стоит кэшировать, если это целесообразно (смотреть на hit ratio).
- **Меняются редко (дни, недели, месяцы)** — можно спокойно кэшировать эти данные.

#### Кэширование ошибок

Кэширование ошибок позволяет снизить нагрузку на источник данных при повторных запросах, предотвращая так называемую "cache miss attack", которая может привести к перегрузке базы данных.

#### Полезность кэша

Эффективность кэширования можно измерить следующим образом:

$$
\text{AverageTime} = \text{DBAccessTime} \times \text{CacheMissRate} + \text{CacheAccessTime}
$$
**Пример:**

- DBAccessTime = 100ms
- CacheAccessTime = 20ms

При CacheMissRate > 0.8 кэш становится вредным, так как время доступа к данным будет превышать 100ms. В таком случае лучше использовать базу данных без кэша.
##### Виды кэширования

**Внутреннее кэширование**

- Кэш внутри сервиса (сервис станет *stateful*).
- **Плюсы:** высокая скорость, отсутствие сетевых запросов, нет расходов на маршалинг/демаршалинг данных.
- **Минусы:** сложное горизонтальное масштабирование, необходимость прогрева кэша после падения сервиса.

![Внутреннее кэширование](https://i.imgur.com/WExPRL3.png)

**Внешнее кэширование**

- Сервис не хранит кэшированные данные, а обращается к внешнему хранилищу.
- **Плюсы:** хранение большого объема данных, простое горизонтальное масштабирование, данные не теряются после падения сервиса, простой прогрев кэша и инвалидация.
- **Минусы:** медленнее по скорости работы.

![Внешнее кэширование](https://i.imgur.com/l2oV3EJ.png)
##### Способы взаимодействия с кэшем

**Cache Aside (кэширование на стороне)**

- Приложение координирует запросы к кэшу и базе данных, решая, куда и когда обращаться.

![Cache Aside](https://i.imgur.com/4LvGfdn.png)

![](https://i.imgur.com/ouBvOGs.png)

**Cache Through (сквозное кэширование)**

- Все запросы от приложения проходят через кэш, и приложение знает только о кэше. Если кэш упадет - упадет и приложение.

![Cache Through](https://i.imgur.com/r3Wr0zO.png)

![](https://i.imgur.com/oMw7vJj.png)

**Cache Ahead (опережающее кэширование)**

- Запросы на чтение всегда идут только в кэш, никогда не попадая в базу данных напрямую.

![Cache Ahead](https://i.imgur.com/URnCSnM.png)
##### Алгоритмы вытеснения данных

Когда кэш заполняется и нет места для новых данных, необходимо удалить старые данные.
##### Random

**Описание:** Удаляет случайно выбранный элемент из кэша.

**Когда использовать:**
- В системах с низкой чувствительностью к эффективности кэширования.
- Для тестирования и отладки.

![Random](https://i.imgur.com/yUqq8Fs.png)
##### FIFO (First In, First Out)

**Описание:** Удаляет данные, которые были добавлены в кэш первыми (первый пришел — первый ушел).

**Когда использовать:**
- В приложениях, где данные имеют ограниченное время жизни и быстро устаревают.
- В системах с потоковой обработкой данных.

![FIFO](https://i.imgur.com/hVjdbcv.png)
##### LIFO (Last In, First Out)

**Описание:** Удаляет последние добавленные данные (последний пришел — первый ушел).

**Когда использовать:**
- В приложениях, где недавно добавленные данные менее важны.
- В специализированных задачах, где наиболее старые данные имеют приоритет.

![LIFO](https://i.imgur.com/qB9xGbv.png)
##### LRU (Least Recently Used)

**Описание:** Удаляет данные, которые не использовались дольше всех.

**Когда использовать:**
- В системах, где важны последние использованные данные.
- В веб-кэшах, кэшах браузеров и оперативной памяти.

![LRU](https://i.imgur.com/D7V9hRM.png)
##### MRU (Most Recently Used)

**Описание:** Удаляет последние использованные данные.

**Когда использовать:**
- В специфических сценариях, где наиболее старые данные имеют приоритет над новыми.
- В системах с прогнозированием на основе истории использования данных.

![MRU](https://i.imgur.com/jDO578I.png)
##### LFU (Least Frequently Used)

**Описание:** Удаляет данные, которые реже всего использовались.

**Когда использовать:**
- В системах, где важны часто используемые данные.
- В кэшах баз данных и файловых системах.

![LFU](https://i.imgur.com/7uOnJJR.png)
##### Алгоритм Белади (OPT)

**Описание:** Теоретический алгоритм, который удаляет данные, которые не будут использоваться дольше всего в будущем.

**Когда использовать:**
- В теоретических исследованиях и для сравнения с другими алгоритмами.
- Невозможен для реализации на практике, так как требует знания будущих запросов.

![Алгоритм Белади](https://i.imgur.com/ycnsguz.png)
##### Second Chance

**Описание:** Модификация FIFO с использованием бита присутствия. При вытеснении проверяет бит присутствия: если бит равен 0, данные удаляются, если бит равен 1, бит сбрасывается и данные остаются.

**Когда использовать:**
- В системах, где важна как давность, так и частота использования данных.
- В ОС для управления страницами памяти.

![Second Chance](https://i.imgur.com/E8aKqes.png)
##### Clock

**Описание:** Аналог Second Chance, но элементы не перемещаются. Вместо этого указатель перемещается по кругу, проверяя бит присутствия.

**Когда использовать:**
- В системах с ограниченными ресурсами, где важна как давность, так и частота использования данных.
- В операционных системах для управления кэш-памятью.

![Clock](https://i.imgur.com/KNtEv45.png)
##### 2Q

**2Q** — или две очереди, примечателен тем, что сохраняя простоту реализации, он прекрасно адаптируется. Кэш разделяется на три части, как в сегментированном LRU, но с более сложной стратегией:
- *Первая часть In* — FIFO входящий кеш в который помещаются новые элементы.
- *Вторая часть Out* — FIFO исходящий кеш, в который перемещаются элементы, вытесненные из коробочки In.
- *Третья часть Hot LRU* кеш для элементов, запрошенных из Out.

Стратегия вытеснения из кеша:  
- элементы запрошенные из In никуда не двигаются. Вытесненные из In элементы — перемещаются в Out.
- элементы запрошенные из Out — попадают в рай, в коробочку Main. Вытесненные же из Out (не использованные) — попадают сразу в ад (null).

![2Q](https://i.imgur.com/AB1gfCn.png)
##### SLRU (Segmented LRU)

**Описание:** Данные разделены на сегменты. При повторном использовании данных они перемещаются в более приоритетный сегмент.

**Когда использовать:**
- В системах, где необходимо учитывать как давность, так и частоту использования данных.
- В распределенных кэш-системах и системах с многосегментной памятью.

![SLRU](https://i.imgur.com/Nm7Uc0j.png)
##### TLRU (Time-aware LRU)

**Описание:** Аналог LRU, но данные имеют время жизни (TTL), по истечении которого они автоматически удаляются.

**Когда использовать:**
- В системах, где данные имеют ограниченное время актуальности.
- В кэшах с временными ограничениями на данные, например, веб-кэшах.
##### LRU-k

**Описание:** Удаляет страницу, последний доступ к которой находится дальше всего в прошлом (в соответствии со временем предпоследнего доступа для LRU-2).

**Когда использовать:**
- В системах, где важно учитывать частоту использования данных.
- В кэшах баз данных для оптимизации производительности.
#### Observability

Observability (наблюдаемость) — это способность системы предоставлять информацию о своем внутреннем состоянии. Основные инструменты и метрики наблюдаемости позволяют разработчикам и операторам отслеживать и анализировать работу системы, быстро выявлять и устранять проблемы.
##### Prometheus

**Prometheus** — это система мониторинга и оповещения с открытым исходным кодом, предназначенная для сбора и хранения метрик в виде временных рядов. Он поддерживает сложные запросы и правила оповещения.

**Зачем использовать:**
- Сбор метрик с различных сервисов и приложений.
- Установка правил оповещения для своевременного уведомления о проблемах.
##### Grafana

**Grafana** — это инструмент для визуализации данных, который интегрируется с Prometheus и другими системами мониторинга. Он позволяет создавать информативные дашборды и графики для отображения метрик.

**Зачем использовать:**
- Визуализация метрик для удобного мониторинга.
- Создание кастомных дашбордов для различных команд и целей.
##### Jaeger

**Jaeger** — это система трассировки распределенных систем, предназначенная для мониторинга и отладки транзакций в микросервисной архитектуре.

**Зачем использовать:**
- Отслеживание путей запросов через распределенную систему.
- Анализ производительности и выявление узких мест.
##### Zipkin

**Zipkin** — система для трассировки распределенных систем, которая позволяет собирать и анализировать данные о прохождении запросов через различные сервисы.

**Зачем использовать:**
- Детальный анализ задержек и ошибок в распределенных системах.
- Улучшение времени отклика и надежности сервисов.
##### Elasticsearch, Logstash и Kibana (ELK Stack)

**Elasticsearch:** Elasticsearch — это движок для полнотекстового поиска и аналитики, который используется для хранения и анализа логов и метрик.

**Logstash:** Logstash — инструмент для сбора, обработки и передачи логов в Elasticsearch.

**Kibana:** Kibana — инструмент для визуализации данных из Elasticsearch, позволяющий создавать дашборды и проводить аналитику.

**Зачем использовать:**
- Сбор и хранение логов в централизованном репозитории.
- Анализ логов и метрик в реальном времени.
- Визуализация данных и создание дашбордов для мониторинга.
##### Graylog

**Graylog:** Graylog — это система для управления логами с возможностями поиска и анализа. Она поддерживает централизованный сбор и обработку логов.

**Зачем использовать:**
- Централизованное управление логами.
- Анализ и поиск по логам для выявления проблем и инцидентов.
- Уведомления о подозрительных активностях.
##### Parca

**Parca** — это инструмент для профилирования производительности, который помогает анализировать и оптимизировать использование ресурсов в реальном времени.
##### Pyroscope

**Pyroscope** — инструмент для профилирования, который позволяет отслеживать использование CPU и памяти.

**Зачем использовать:**
- Профилирование производительности приложений.
- Выявление узких мест и оптимизация использования ресурсов.
##### Sentry

**Sentry** — это система для мониторинга и отслеживания ошибок в приложениях. Она собирает информацию о ошибках, исключениях и сбоях, помогая разработчикам быстро их выявлять и устранять.

**Зачем использовать:**
- Сбор и анализ ошибок и исключений в приложениях.
- Уведомления о критических ошибках для оперативного реагирования.
- Анализ причин ошибок и улучшение качества кода.
##### Основные метрики

- **RPS (Requests Per Second), TPS (Transactions Per Second), QPS (Queries Per Second):** Частота запросов или транзакций в секунду, указывает на нагрузку на систему.
- **Response time:** Время отклика системы на запросы, важный показатель производительности.
- **Errors rate:** Частота ошибок, помогает отслеживать стабильность и надежность системы.
- **Traffic:** Объем сетевого трафика, указывает на загрузку сети.
- **CPU, RAM, HDD/SDD:** Использование процессора, оперативной памяти и дискового пространства, помогает контролировать ресурсы.
- **Uptime / Downtime:** Время работы и простоя системы, важный показатель надежности.
- **Размеры очередей:** Длина очередей задач, указывает на загруженность системы.
- **Количество процессов / потоков:** Количество активных процессов и потоков, помогает оценить параллелизм и производительность.
### Краткое содержание
