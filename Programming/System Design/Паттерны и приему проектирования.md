---
создал заметку: 2024-08-02
tags:
  - system-design
---
### Описание

#### Rolling Release (Постепенное развертывание)

**Постепенное развертывание** - это процесс обновления программного обеспечения, при котором новая версия развертывается на серверах поэтапно, вместо того чтобы обновлять все сразу.

![](https://i.imgur.com/5MHO8y4.png)

**Аналогия:** Представьте себе, что в большом здании нужно заменить все окна. Вместо того чтобы одновременно менять окна во всех комнатах, рабочие заменяют окна по одному этажу за раз. Так, если возникнут проблемы на одном этаже, их можно быстро исправить, прежде чем продолжить работу на следующем.

**Применение:**

1. **Разработчики** обновляют программное обеспечение на небольшом наборе серверов.
2. **Мониторинг** ведется на этих серверах для выявления ошибок и производительности.
3. **Обновление** распространяется на следующую группу серверов, если всё в порядке.
4. **Процесс** продолжается до тех пор, пока все серверы не будут обновлены.
#### Blue/Green Release (Синие/Зеленые развертывание)

**Blue/Green развертывание** - это метод обновления, при котором существует два идентичных окружения: "синее" и "зеленое". Одна из них активна (синяя) и обслуживает пользователей, в то время как вторая (зеленая) используется для развертывания новой версии программного обеспечения.

![](https://i.imgur.com/3Hr6UVt.png)

**Аналогия:** Представьте, что у вас есть два ресторана: один работает и обслуживает клиентов (синий), а другой закрыт на обновление меню и ремонт (зеленый). Когда зеленый ресторан будет готов, вы открываете его и закрываете синий на обновление.

**Применение:**

1. **Текущая версия** программы работает в синем окружении.
2. **Новая версия** разворачивается и тестируется в зеленом окружении.
3. **Переключение трафика**: если новая версия стабильна, весь пользовательский трафик перенаправляется на зеленое окружение.
4. **Синий** окружение остается в резерве, готовое вернуться, если возникнут проблемы с зеленым.
#### Canary Release (Канарейка)

**Canary Release** - это метод, при котором новая версия программного обеспечения сначала развертывается на небольшой группе пользователей перед тем, как будет распространена на всех.

![](https://i.imgur.com/bsPeqVt.png)

**Аналогия:** Представьте шахту, где для проверки безопасности запускают канарейку перед тем, как зайдут шахтеры. Если канарейка вернулась живой, значит, шахта безопасна. Если нет, шахтеры знают о проблеме и решают ее до того, как зайти в шахту.

**Применение:**

1. **Малая группа пользователей** получает доступ к новой версии программного обеспечения.
2. **Мониторинг** ведется за их взаимодействиями, чтобы выявить ошибки или проблемы производительности.
3. **Если** все идет хорошо, новая версия постепенно распространяется на большую группу пользователей до полного развертывания.
#### MVP (Минимально жизнеспособный продукт)

**MVP** — это стратегия разработки продукта, при которой создается минимальная версия продукта с достаточным количеством функций, чтобы удовлетворить ранних пользователей и собрать обратную связь для дальнейшего улучшения продукта.

![](https://i.imgur.com/mN8liUL.png)
#### Трехзвенная архитектура (Three-Tier Architecture)

**Трехзвенная архитектура** - это метод организации программного обеспечения, который разделяет его на три независимые, но взаимосвязанные слои. Эти слои разделены для улучшения масштабируемости, управляемости и повторного использования компонентов.

![](https://i.imgur.com/jDbDcek.png)

**Основные слои трехзвенной архитектуры**

1. **Презентационный слой (Presentation Layer)**: Этот слой отвечает за взаимодействие с пользователем. Он включает в себя пользовательский интерфейс и отображает данные, полученные от других слоев, а также собирает ввод от пользователя.

2. **Логический слой (Business Logic Layer)**: Этот слой отвечает за обработку данных и бизнес-логику. Он содержит всю логику приложения, правила и алгоритмы, необходимые для выполнения задач, поставленных пользователем.

3. **Датовый слой (Data Layer)**: Этот слой отвечает за управление данными, их хранение и доступ к ним. Он взаимодействует с базами данных или другими источниками данных, чтобы сохранить и извлечь нужную информацию.
#### Толстый клиент (Thick Client)

Толстый клиент, также известный как "толстый клиент" или "rich client" - это архитектура клиент-серверного приложения, в которой большая часть обработки данных и логики приложения выполняется на стороне клиента (устройство пользователя), а не на сервере.

![](https://i.imgur.com/86w33gB.png)

**Аналогия:**

Представьте себе библиотеку. В традиционной библиотеке (тонкий клиент) вы бы пошли к библиотекарю (серверу) для каждой книги, которую хотите прочитать, и он бы принес вам книгу. В библиотеке с толстым клиентом, у вас есть доступ ко всем книгам на своих книжных полках (локальное хранение данных и логика), и вы обращаетесь к библиотекарю только для редких запросов, таких как получение новой книги, которой у вас еще нет.

#### Паттерн Pub/Sub (Publisher/Subscriber)

**Pub/Sub (Publisher/Subscriber)** - это шаблон архитектуры, который разделяет отправителей сообщений (издателей) и получателей сообщений (подписчиков) через посредника, называемого брокером сообщений. Этот шаблон используется для асинхронного обмена сообщениями и масштабирования систем.

![](https://i.imgur.com/93sw5R8.png)

**Основные компоненты Pub/Sub:**

1. **Издатель (Publisher):**
    
    - Издатель создает сообщения и отправляет их брокеру сообщений.
    - Издатель не знает, кто получит сообщения и сколько подписчиков у него есть.
    
1. **Брокер сообщений (Message Broker):**
    
    - Брокер сообщений принимает сообщения от издателей и распределяет их среди подписчиков.
    - Брокер обеспечивает маршрутизацию и доставку сообщений.
    
1. **Подписчик (Subscriber):**
    
    - Подписчик регистрируется у брокера сообщений для получения сообщений определенного типа.
    - Подписчик обрабатывает полученные сообщения.
    

**Аналогия:**

Представьте себе новостную рассылку. Газета (издатель) пишет статьи и отправляет их в типографию (брокер сообщений). Типография, в свою очередь, распределяет газеты по почтовым ящикам подписчиков. Подписчики (люди, которые подписались на газету) получают газеты и читают их.
#### Heartbeat (Сигнал «сердцебиение»)

**Heartbeat** - это механизм, используемый в распределенных системах для мониторинга состояния компонентов системы и обеспечения их работоспособности. С помощью сигналов "сердцебиение" (heartbeat) системы могут проверять наличие и состояние других систем или узлов в сети.

![](https://i.imgur.com/kxMVbvX.png)

**Аналогия:**

Представьте себе, что у вас есть группа друзей, которые договорились периодически отправлять друг другу короткие сообщения, чтобы убедиться, что все в порядке. Если кто-то из друзей перестает отправлять сообщения, остальные друзья понимают, что что-то не так, и могут проверить, в чем проблема.
#### Service Discovery (Обнаружение сервисов)

**Service Discovery (обнаружение сервисов**) - это механизм, используемый в распределенных системах и микросервисной архитектуре для автоматического определения местоположения и состояния различных сервисов. Этот механизм помогает динамически управлять подключением между сервисами, обеспечивая масштабируемость и отказоустойчивость системы.

![](https://i.imgur.com/9CGaafr.png)

**Аналогия:**

Представьте себе большой отель с множеством номеров. Регистратор сервисов — это стойка регистрации, где хранится информация о каждом номере (сервисе), таких как его номер, статус (занят/свободен) и расположение (этаж). Гости (сервисы-клиенты) обращаются к стойке регистрации, чтобы узнать, в каком номере они могут поселиться или где найти нужные им услуги.

#### CQRS (Command Query Responsibility Segregation)

**CQRS** (Разделение ответственности за команды и запросы) - это архитектурный шаблон, который разделяет операции изменения данных (команды) и операции чтения данных (запросы) в отдельные модели. Этот подход помогает улучшить производительность, масштабируемость и безопасность системы.

![](https://i.imgur.com/j29lIeU.png)

**Аналогия:**

Представьте себе ресторан. У вас есть официанты, которые принимают заказы (команды) и передают их на кухню. Кухня (модель команд) обрабатывает заказы, готовит еду и обновляет статус заказа. Когда еда готова, официант (модель запросов) приносит её к столу и сообщает клиенту, что заказ готов.
#### Retries (Повторные попытки)

**Retries (повторные попытки)** - это механизм, используемый в сетевых приложениях для повышения надежности и устойчивости систем. При возникновении временных ошибок, таких как сетевые сбои или перегрузка сервера, система может автоматически повторить запрос, надеясь на успешное выполнение при следующей попытке.

![](https://i.imgur.com/sLfLKqY.png)

Нужно найти компромисс между:
- ﻿﻿пользовательский запрос - расшибись, но ответь
- ﻿﻿лучше ответить ошибкой, чем перегрузкой сервисов
- ﻿﻿при неидемпотентных запросах нельзя повторять определенные типы запросов
##### Идемпотентность

Свойство объекта или операции (GET, PUT, DELETE) при повторном применении операции к объекту давать тот результат, что и при первом

![](https://i.imgur.com/So1GQAD.png)
##### backoff

Повтор через фиксированный интервал времени и экспоненциальное откладывание

![](https://i.imgur.com/a5enXAj.png)
#### Проблема backpressure

![](https://i.imgur.com/8Y0X75n.png)

Если Service 1 шлет 150 запросов в секунду в Service 2, a Service 2 может обработать только 100, значит после часа работы будет 180 000 запросов, с которыми непонятно, что делать...

Решение: либо rate limiter (обрубаем лишние запросы от сервиса 1), либо начинаем придерживать запросы (отвечаем чуть медленней)
#### Circuit breaker (выключатель)

Выключаем сервер на какое-то время, если серверу плохо или нужна безопасность от ретраев
1. ﻿﻿﻿Closed (трафик приходит)
2. ﻿﻿﻿Open (не пропускаем трафик к серверу)
3. ﻿﻿﻿Half - open (20% запросов пускаем, остальные обрубаем)

![](https://i.imgur.com/Pqp6lFJ.png)
#### Паттерн Graceful Degradation (Плавная деградация)

**Graceful Degradation (плавная деградация)** - это архитектурный паттерн, который позволяет системе продолжать работать даже при частичных сбоях. Основная идея заключается в том, чтобы система могла снижать свои функции и производительность, вместо полного выхода из строя. Это помогает минимизировать воздействие сбоев на пользователей и поддерживать базовый уровень обслуживания.

![](https://i.imgur.com/Xlb1XlV.png)

**Аналогия:**

Представьте себе автомобиль, у которого неожиданно перестает работать кондиционер. Вместо того чтобы полностью остановиться, автомобиль продолжает ехать, просто без охлаждения. Вы по-прежнему можете добраться до пункта назначения, хоть и с некоторыми неудобствами.
#### Fallback (Резервный механизм)

**Fallback (резервный механизм)** - это архитектурный паттерн, используемый для обеспечения устойчивости и надежности системы при возникновении сбоев. При сбое основного компонента или сервиса система автоматически переключается на резервный механизм или альтернативный процесс, чтобы продолжить выполнение задачи.

![](https://i.imgur.com/nDESDnb.png)

**Аналогия:**

Представьте себе, что вы работаете на фабрике, которая использует основной генератор для обеспечения электроэнергией. В случае отказа основного генератора, фабрика автоматически переключается на резервный генератор, чтобы продолжить работу без остановок.
#### Отложенное выполнение задач

**Отложенное выполнение задач (Delayed Task Execution)** — это подход в программировании, при котором выполнение определенной задачи откладывается на определенное время или до наступления определенного события. Этот подход широко используется для оптимизации производительности системы, управления ресурсами и повышения устойчивости.

**Аналогия:** загружаем видео на youtube

![](https://i.imgur.com/tugsSOm.png)
#### Polling

**Polling (опрашивание)** — это метод периодического проверки состояния или данных от ресурса или сервиса для получения обновленной информации.

![](https://i.imgur.com/Eg2VLJh.png)
#### Long Polling

**Long Polling (долгое опрашивание)** — это техника, используемая для реализации асинхронных коммуникаций в веб-приложениях. Она позволяет клиенту получать обновления с сервера без необходимости постоянного опрашивания, тем самым *уменьшая нагрузку на сеть и сервер*.

![](https://i.imgur.com/nGczlda.png)
#### Streaming

**Streaming (стриминг)** — это технология, позволяющая передавать данные непрерывным потоком. Этот подход используется для передачи мультимедийного контента (видео, аудио) и обработки данных в реальном времени. В отличие от традиционных методов передачи данных, где данные передаются пакетами, стриминг позволяет воспроизводить данные по мере их получения, что уменьшает задержки и повышает производительность.

![](https://i.imgur.com/VmWqL6x.png)
#### MapReduce

**MapReduce** — это модель программирования и связанная с ней реализация для обработки и генерации больших наборов данных с параллельным распределением задач по кластеру серверов. Этот подход был первоначально разработан Google для обработки огромных объемов данных.

![](https://i.imgur.com/TqMMxQn.png)
#### Подходы при микросервисных архитектурах

![](https://i.imgur.com/zLtbhn6.png)

![](https://i.imgur.com/qMUaiv1.png)
#### Событийно-ориентированная архитектура

**Event Notification**

1. ﻿﻿﻿Обрабатываем запрос
2. ﻿﻿﻿Отпускаем клиента
3. ﻿﻿﻿Используем события

![](https://i.imgur.com/vFd6H3W.png)

**State Tranfer**

1. ﻿﻿﻿Обрабатываем запрос
2. ﻿﻿﻿Отпускаем клиента
3. ﻿﻿﻿Используем события
4. ﻿﻿﻿Реплицируем данные

![](https://i.imgur.com/LH6aMWr.png)

**Event Collaboration**

Используется шина для коммуникации между сервисами

![](https://i.imgur.com/4FZFzOM.png)
#### Throttling / debouncing

#### Консенсус

Необходимость нескольких узлов согласовать определенные действия между собой
##### Распределенные транзакции

![](https://i.imgur.com/guEwpaO.png)

##### Двухфазная транзакция (2PC)

В ЗАГСе перед тем, как обручить супругов у них спрашивают согласия и только затем обручают (итого получается две фазы - подготовка и фиксация)

![](https://i.imgur.com/zBy3CY3.png)

![](https://i.imgur.com/j6C8A1a.png)

![](https://i.imgur.com/hapY24f.png)

![](https://i.imgur.com/QcoXL8N.png)
##### Saga

Представляет собой набор локальных транзакций.

Каждая локальная транзакция обновляет базу данных и публикует сообщение или событие, инициируя следующую локальную транзакцию

![](https://i.imgur.com/xY98Dej.png)

![](https://i.imgur.com/98H2JW9.png)
##### Transaction Outbox

![](https://i.imgur.com/AKhiL4z.png)
##### Распределенные блокировки

![](https://i.imgur.com/GoTYfFq.png)

![](https://i.imgur.com/3YVKKbv.png)
#### Выбор лидера, когда упал мастер

Каждый мастер должен отправлять запрос (на картинке key-value etcd) на продление своей аренды, как только мастер перестанет это делать и срок аренды истечет, тогда реплики начнут кидать запрос на выдачу аренды и мастером станет тот, кто будет первым

![](https://i.imgur.com/whArzuU.png)
##### Алгоритм забияки

У каждого узла есть ранг

![](https://i.imgur.com/Xsum3ij.png)

![](https://i.imgur.com/R1FbDcB.png)

![](https://i.imgur.com/Ij7Ai4B.png)

![](https://i.imgur.com/6qLyPcc.png)

![](https://i.imgur.com/XYJXyUs.png)
##### Raft и Paxos

#### Установка требований

##### Функциональные требования

**Заявление о том, как должна вести себя система**. Оно определяет, что система должна делать, чтобы удовлетворить потребности или ожидания пользователя. Функциональные требования можно рассматривать как функции, которые обнаруживает пользователь.
##### Нефункциональные требования

**Требования, определяющие свойства, которые система должна демонстрировать, или ограничения, которые она должна соблюдать, не относящиеся к поведению системы.** Например, производительность, удобство сопровождения, расширяемость, надежность.

### Краткое содержание
